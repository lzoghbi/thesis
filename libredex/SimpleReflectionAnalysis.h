/**
 * Copyright (c) 2016-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

#pragma once

#include <memory>
#include <ostream>

#include <boost/optional.hpp>

#include "DexClass.h"
#include "IRInstruction.h"

namespace sra {

namespace impl {

// Forward declarations.
class Analyzer;

} // namespace impl

/*
 * This analysis performs an intraprocedural constant propagation on a variety
 * of objects involved in reflective calls. It is aimed at exposing simple yet
 * common use cases of reflection.
 *
 * Example:
 *
 *   Bar bar_obj = new Bar();                          --> OBJECT(Bar)
 *   java.lang.Class foo_class = Foo.class;            --> CLASS(Foo)
 *   java.lang.Class bar_class = bar_obj.getClass();   --> CLASS(Bar)
 *   Field f = foo_class.getField("foo");              --> FIELD(Foo, "foo")
 *   Method m = bar_class.getMethod("bar");            --> METHOD(Bar, "bar")
 *   String s1 = f.getName();                          --> STRING("foo")
 *   String s2 = m.getName();                          --> STRING("bar")
 *   java.lang.Class baz_class = Class.forName("Baz"); --> CLASS(Baz)
 *
 * Note that the signature of a method is not tracked by the analysis. In the
 * example above, f may refer to any method named "foo" in the class Foo.
 */

enum AbstractObjectKind {
  OBJECT, // An object created with `new`
  STRING, // A string literal
  CLASS,  // A java.lang.Class object
  FIELD,  // A java.lang.reflect.Field object
  METHOD, // A java.lang.reflect.Method object
};

struct AbstractObject {
  AbstractObjectKind kind;
  DexType* dex_type;
  DexString* dex_string;

  // AbstractObject must be default constructible in order to be used as an
  // abstract value.
  AbstractObject() = default;

  explicit AbstractObject(DexString* s)
      : kind(STRING), dex_type(nullptr), dex_string(s) {}

  AbstractObject(AbstractObjectKind k, DexType* t)
      : kind(k), dex_type(t), dex_string(nullptr) {
    always_assert(k == OBJECT || k == CLASS);
  }

  AbstractObject(AbstractObjectKind k, DexType* t, DexString* s)
      : kind(k), dex_type(t), dex_string(s) {
    always_assert(k == FIELD || k == METHOD);
  }
};

bool operator==(const AbstractObject& x, const AbstractObject& y);

bool operator!=(const AbstractObject& x, const AbstractObject& y);

std::ostream& operator<<(std::ostream& out, const AbstractObject& x);

class SimpleReflectionAnalysis final {
 public:
  // If we don't declare a destructor for this class, a default destructor will
  // be generated by the compiler, which requires a complete definition of
  // sra_impl::Analyzer, thus causing a compilation error. Note that the
  // destructor's definition must be located after the definition of
  // sra_impl::Analyzer.
  ~SimpleReflectionAnalysis();

  explicit SimpleReflectionAnalysis(DexMethod* dex_method);

  /*
   * Returns the abstract object (if any) referenced by the register at the
   * given instruction. Note that if the instruction overwrites the register,
   * the abstract object returned is the value held by the register *before*
   * that instruction is executed.
   */
  boost::optional<AbstractObject> get_abstract_object(
      size_t reg, IRInstruction* insn) const;

 private:
  std::unique_ptr<impl::Analyzer> m_analyzer;
};

} // namespace sra
